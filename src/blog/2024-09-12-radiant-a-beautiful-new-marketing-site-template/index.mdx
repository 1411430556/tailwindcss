import { danhollick } from "@/app/blog/authors";
import twitterCard from "./twitter-card.png";
import template from "./template.png";
import { Image, Video } from "@/components/media";
import savvycalRadiant from "./savvycal-radiant.jpg";
import sanityStudio from "./sanity-studio.png";
import blog from "./blog.png";

export const meta = {
  title: "Radiant: 一个美丽的新市场网站模板",
  description: `在过去的几个月里，我们一直在努力工作，开发一个新的SaaS模板叫做Radiant，现在作为Tailwind UI的一部分发布了。`,
  date: "2024-09-12T10:30:00.000Z",
  authors: [danhollick],
  image: twitterCard,
  excerpt: (
    <>
      在过去的几个月里，我们一直在努力开发一个新的SaaS市场网站模板为Tailwind UI。它叫做 <a href="https://tailwindui.com/templates/radiant">Radiant</a>，你今天就可以开始使用它。
    </>
  ),
};

<a href="https://tailwindui.com/templates/radiant">
  <Image src={template} alt="Learn about the Radiant template" />
</a>

We just wrapped up work on a beautiful new SaaS marketing site template called [Radiant](https://tailwindui.com/templates/radiant), and it's available now as part of [Tailwind UI](https://tailwindui.com).

It’s built with Next.js, Framer Motion, and Tailwind CSS, with a blog powered by Sanity.

It's been a while since we built a SaaS marketing template like this, and in that time we've learned a lot about what makes a template like this useful and easy to work with. We've tried to incorporate all of those learnings into Radiant.

Check out the [live preview](https://radiant.tailwindui.com) as always for the full experience — there are tons of cool details in this one that you have to see in the browser to really appreciate.

---

## Tastefully interactive

It's super easy to overdo animation on a site like this. We've all seen sites where you can't even scroll a few pixels without a bunch of different elements animating in to place. Even worse is how slow things feel when you have to wait for the content to appear before you can read it.

Radiant is loaded with delightful animations, but they are all layered on to existing content and triggered by user interaction so the site still feels fast. In most cases, we went for animations that loop to make elements feel "alive" while you're interacting with them.

<Video src="https://assets.tailwindcss.com/blog/2024-09-12-radiant-a-beautiful-new-marketing-site-template/scheduling-animation.mp4" />

We used [Framer Motion](https://www.framer.com/motion/) for almost all of the animations. It's declarative, making it easy to create our own APIs for complex animations that other people can customize without much effort.

It does have some drawbacks to work around though. For example, when you have multiple elements animating independently it's annoying to pass a hover state down to each child. We ended up leveraging Framer's variant propagation to make this work — a hover event triggers a variant change in the parent that propagates down to the children because they share the same variant keys.

```jsx
// [!code filename:bento-card.tsx]
export function BentoCard() {
  return (
    // [!code highlight:7]
    <motion.div
      initial="idle"
      whileHover="active"
      variants={{ idle: {}, active: {} }}
      data-dark={dark ? "true" : undefined}
    >
      /* ... */
    </motion.div>
  );
}
```

父元素中的变体没有区别，因此实际上不会更改，但子元素在悬停时仍然获得变更变体的信号，即使它们嵌套得很深。

```jsx
// [!code filename:map.tsx]
function Marker({
  src,
  top,
  offset,
  delay,
}: {
  src: string
  top: number
  offset: number
  delay: number
}) {
  return (
    <motion.div
      variants={{
        // [!code highlight:3]
        idle: { scale: 0, opacity: 0, rotateX: 0, rotate: 0, y: 0 },
        active: { y: [-20, 0, 4, 0], scale: [0.75, 1], opacity: [0, 1] },
      }}
      transition={{ duration: 0.25, delay, ease: 'easeOut' }}
      style={{ '--offset': `${offset}px`, top } as React.CSSProperties}
      className="absolute left-[calc(50%+var(--offset))] size-[38px] drop-shadow-[0_3px_1px_rgba(0,0,0,.15)]"
    >
      /* ... */
    </motion.div>
  )
}

/* ... */
```

The logo timeline animation is a bit different, because we wanted the logos to pause in their current position when you stop hovering, rather than return to their original position. This doesn't play very well with Framer's approach of specifying start and end states, so it was actually easier to build this in CSS.

<Video src="https://assets.tailwindcss.com/blog/2024-09-12-radiant-a-beautiful-new-marketing-site-template/logo-timeline.mp4" />

It exploits the fact that you can set a negative `animation-delay` value to offset the start position of the element. That way all the logos share the same animation keyframes but they can start at different positions and have different durations.

```jsx
// [!code filename:logo-timeline.tsx]
function Logo({
  label,
  src,
  className,
}: {
  label: string
  src: string
  className: string
}) {
  return (
    <div
      className={clsx(
        className,
        'absolute top-2 grid grid-cols-[1rem,1fr] items-center gap-2 whitespace-nowrap px-3 py-1',
        'rounded-full bg-gradient-to-t from-gray-800 from-50% to-gray-700 ring-1 ring-inset ring-white/10',
        // [!code highlight:2]
        '[--move-x-from:-100%] [--move-x-to:calc(100%+100cqw)] [animation-iteration-count:infinite] [animation-name:move-x] [animation-play-state:paused] [animation-timing-function:linear] group-hover:[animation-play-state:running]',
      )}
    >
      <img alt="" src={src} className="size-4" />
      <span className="text-sm/6 font-medium text-white">{label}</span>
    </div>
  )
}

export function LogoTimeline() {
  return (
    /* ... */
    <Row>
      <Logo
        label="Loom"
        src="./logo-timeline/loom.svg"
        // [!code highlight:2]
        className="[animation-delay:-26s] [animation-duration:30s]"
      />
      <Logo
        label="Gmail"
        src="./logo-timeline/gmail.svg"
        // [!code highlight:2]
        className="[animation-delay:-8s] [animation-duration:30s]"
      />
    </Row>
    /* ... */
```

This approach means we don't need to track the play state in JavaScript, we can just use a `group-hover:[animation-play-state:running]` class to start the animation when the parent is hovered.

As you've maybe noticed, we're using a bunch of arbitrary properties for individual `animation` properties in this component, since these utilities don't exist in Tailwind today. This is what's great about building these templates — it helps us find blind spots in Tailwind CSS. Who knows, maybe we'll see these utilities added for v4.0!

---

## Deliberately reusable

The trickiest part of designing a SaaS template like this, is coming up with interactive elements that people can apply to their own product without too much effort. There's nothing worse than buying a template and realizing that it's so specific to the example content that you can't actually use it for your own project.

<Video src="https://assets.tailwindcss.com/blog/2024-09-12-radiant-a-beautiful-new-marketing-site-template/light-bento.mp4" />

We came up with some core graphical elements that most SaaS products might have. A map with pins, a logo cluster, a keyboard — things that could be applied to a bunch of different features. Because we wanted them to be easy to repurpose for your own product, we built a lot of them in code and designed nice APIs for them.

The logo cluster, for example, has a simple API that lets you pass in your own logos, tweak their position and hover animation to match.

```jsx
<Logo src="./logo-cluster/dribbble.svg" left={285} top={20} hover={{ x: 4, y: -5, rotate: 6, delay: 0.3 }} />
```

键盘快捷键部分是另一个很好的例子。只需将一个键名数组传递给Keyboard组件，即可添加您自己的快捷键，并且因为每个键都是一个组件，您可以轻松添加自定义键或更改布局。

```jsx
<Keyboard highlighted={["F", "M", "L"]} />
```

It turns out it's actually quite a lot of work to build a keyboard in code, but at least now you'll never have to find that out for yourself.

<Video src="https://assets.tailwindcss.com/blog/2024-09-12-radiant-a-beautiful-new-marketing-site-template/keyboard.mp4" />

Of course, we also left spots for you to drop in screenshots of your own product. Here's what this section looks like customized to suit our friends at [SavvyCal](https://savvycal.com/), using the same interactive components.

<Image alt="Radiant作为SavvyCal" src={savvycalRadiant} />

---

## Powered by a CMS

Usually we just use MDX when adding a blog to a template, but this time we thought it would be fun to play with a headless CMS for a chance instead. We decided to give [Sanity](https://www.sanity.io/) a go for this one after [polling our audience](https://x.com/adamwathan/status/1796225062279717142) and hearing a lot of good things.

Instead of creating files, making commits, and managing images and stuff by hand, a CMS lets you handle everything from their UI, so even non-developers can easily contribute.

<Image alt="Sanity Studio" src={sanityStudio} />

像Sanity这样的无头CMS的一个很酷的功能是您获得的内容是结构化格式的，因此与MDX类似，您可以将元素映射到自己的自定义组件，以处理所有的排版样式。

```jsx
<PortableText
  value={post.body}
  components={{
    block: {
      normal: ({ children }) => <p className="my-10 text-base/8 first:mt-0 last:mb-0">{children}</p>,
      h2: ({ children }) => (
        <h2 className="mt-12 mb-10 text-2xl/8 font-medium tracking-tight text-gray-950 first:mt-0 last:mb-0">
          {children}
        </h2>
      ),
      h3: ({ children }) => (
        <h3 className="mt-12 mb-10 text-xl/8 font-medium tracking-tight text-gray-950 first:mt-0 last:mb-0">
          {children}
        </h3>
      ),
      blockquote: ({ children }) => (
        <blockquote className="my-10 border-l-2 border-l-gray-300 pl-6 text-base/8 text-gray-950 first:mt-0 last:mb-0">
          {children}
        </blockquote>
      ),
    },
    types: {
      image: ({ value }) => (
        <img className="w-full rounded-2xl" src={image(value).width(2000).url()} alt={value.alt || ""} />
      ),
    },
    /* ... */
  }}
/>
```

使用CMS还意味着您的所有资产，如图片，都由您托管，并且您可以动态控制图像的大小、质量和格式。

{/* prettier-ignore */}
```jsx
<div className="text-sm/5 max-sm:text-gray-700 sm:font-medium">
  {dayjs(post.publishedAt).format('dddd, MMMM D, YYYY')}
</div>
{post.author && (
  <div className="mt-2.5 flex items-center gap-3">
    {post.author.image && (
      // [!code highlight:6]
      <img
        className="aspect-square size-6 rounded-full object-cover"
        src={image(post.author.image).width(64).height(64).url()}
        alt=""
      />
    )}
    <div className="text-sm/5 text-gray-700">
      {post.author.name}
    </div>
  </div>
)}
```

正如在Markdown中使用前置内容一样，您还可以使用自定义字段丰富内容。例如，我们在博客文章架构中添加了一个`featured`布尔字段，以便您可以在博客的特殊部分突出显示某些帖子。

<Image alt="Radiant博客" src={blog} />

Sanity尤其是一个付费产品，但它有一个相当慷慨的免费套餐，这足以供您玩耍。如果您想尝试不同的无头CMS，我认为我们在这里设置的Sanity集成仍然是一个很好的示例，展示了如何与其他工具连接。

---

这就是 [Radiant](https://tailwindui.com/templates/radiant)! 了解它的内部运作，尝试一下，告诉我们您的看法。

像我们所有的模板一样，它包含在一次性购买的[Tailwind UI全访问](https://tailwindui.com/all-access)许可证中，这是支持我们在Tailwind CSS上工作的最佳方式，让我们能够继续为您构建出色的产品，未来几年内不断创新。
